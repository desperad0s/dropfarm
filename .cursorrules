# Dropfarm Application Development Rules

# Project Overview
project_name: Dropfarm
description: A scalable, headless automation system for web interactions, focusing on airdrop token farming.
primary_languages: [Python, TypeScript]
frameworks: [Flask, Next.js, Celery]
ui_libraries: [shadcn/ui, Tailwind CSS]
database: Supabase
state_management: React Context API
task_queue: Redis with Celery
browser_automation: Selenium WebDriver

# Communication and Collaboration
communication_style:
  - Always maintain a professional and supportive tone
  - Provide detailed explanations for complex concepts
  - Use code snippets and examples to illustrate points
  - Be open to questions and clarifications
  - Acknowledge and learn from mistakes
  - Always report current thoughts on the project state
  - Explain reasoning behind suggested changes or implementations

collaboration_practices:
  - Regularly summarize current project state and next steps
  - Propose multiple solutions when applicable
  - Prioritize user experience and system reliability
  - Consider performance implications of changes
  - Maintain a balance between feature development and code quality
  - Always seek user confirmation before making significant changes
  - Report any autonomous actions taken, with justification

# Code Style and Best Practices
python_style:
  - Follow PEP 8 guidelines
  - Use type hints for improved code clarity
  - Implement comprehensive error handling and logging
  - Write clear, concise docstrings for functions and classes

typescript_style:
  - Use ESLint and Prettier for consistent formatting
  - Leverage TypeScript's type system for robust code
  - Implement React hooks and functional components
  - Follow React best practices for state management

general_practices:
  - Write modular, reusable code
  - Implement comprehensive unit tests
  - Use meaningful variable and function names
  - Keep functions small and focused on a single task
  - Comment complex logic or non-obvious code sections

# Project-Specific Guidelines
calibration_process:
  - Maintain awareness of the three-step calibration (browser, recorder, player)
  - Consider different screen sizes and aspect ratios in calculations
  - Implement robust error handling for calibration failures
  - Provide clear user feedback during the calibration process

automation_guidelines:
  - Ensure all automated actions are reversible where possible
  - Implement safeguards against unintended consequences
  - Log all automated actions for auditing and debugging
  - Design for scalability and potential multi-user scenarios

security_considerations:
  - Implement proper authentication and authorization
  - Sanitize all user inputs to prevent injection attacks
  - Use environment variables for sensitive configuration
  - Regularly update dependencies to patch security vulnerabilities

# Debugging and Troubleshooting
debugging_approach:
  - Use logging extensively for tracking execution flow
  - Implement verbose error messages for easier troubleshooting
  - Utilize browser developer tools for frontend debugging
  - Use Python debugger (pdb) for backend issue investigation

common_issues:
  - Browser compatibility problems
  - Selenium session management issues
  - Asynchronous task handling in Celery
  - State management in React components

# Feature Implementation Process
feature_workflow:
  - Discuss and clarify feature requirements
  - Design the solution, considering all components (frontend, backend, database)
  - Implement the feature with appropriate error handling and logging
  - Write unit tests to cover new functionality
  - Perform manual testing across different environments
  - Document the new feature and any API changes

# Performance Optimization
optimization_focus:
  - Monitor and optimize database queries
  - Implement caching where appropriate
  - Optimize Selenium interactions for faster execution
  - Minimize unnecessary re-renders in React components

# Documentation
documentation_requirements:
  - Maintain up-to-date API documentation
  - Document complex algorithms and business logic
  - Keep README files current with setup and run instructions
  - Comment non-obvious code sections

# Continuous Improvement
improvement_areas:
  - Regularly review and refactor code for better maintainability
  - Stay updated with latest best practices in used technologies
  - Seek user feedback for UX improvements
  - Analyze and optimize system performance regularly

# Project-Specific Reminders
key_reminders:
  - Always consider the impact of changes on the calibration process
  - Ensure compatibility between recorder and player environments
  - Regularly test the full workflow from recording to playback
  - Keep security and data privacy at the forefront of development decisions

# AI Assistant Behavior
ai_assistant_rules:
  - Always consider these rules before responding or suggesting changes
  - Provide a brief assessment of the current project state when appropriate
  - Explain the reasoning behind any suggested changes or implementations
  - Seek explicit confirmation before making any significant changes
  - Report any autonomous actions taken, along with justification
  - Prioritize the user's goals and timeline (beta release this month, 3 concurrent routines by weekend)
  - Regularly remind about testing and validation of implemented features
  - Suggest optimizations and improvements proactively, but await approval before implementation
  - Remind the user to commit changes regularly, especially:
    - Before implementing big changes or new features
    - When a significant amount of time has passed since the last commit
    - After completing a feature or fixing a bug
  - Provide a summary of changes to be committed and instructions on how to do so
  - Keep track of all relevant file paths, directories, and files for the project
  - Proactively mention potential conflicts or issues with file locations or imports

# Project Structure
project_structure:
  backend:
    - app.py
    - auth.py
    - calibration.py
    - celery_worker.py
    - config.py
    - extensions.py
    - models.py
    - player.py
    - recorder.py
    - routes.py
    - tasks.py
    - utils.py
    templates:
      - player_calibration.html
      - recorder_calibration.html
  frontend:
    src:
      app:
        dashboard:
          - page.tsx
        - layout.tsx
        - page.tsx
      components:
        dashboard:
          - ActivityLog.tsx
          - BotStatus.tsx
          - EarningsOverview.tsx
          - RoutinesList.tsx
          - UserStats.tsx
        ui:
          - button.tsx
        - Calibration.tsx
        - ClientLayout.tsx
        - Dashboard.tsx
        - LoginForm.tsx
        - RecordRoutine.tsx
      contexts:
        - AuthContext.tsx
      hooks:
        - useDataFetching.ts
        - useRecordingStatus.ts
        - use-toast.ts
      lib:
        - supabaseClient.ts
      - config.ts
    - globals.css
  - .cursorrules
  - .cursorrules_cursor
  - calibration_considerations.md
  - offset_click_thoughts.md
  - README.md
  - run.py

# Development Environment
local_environment:
  os: Windows
  monitor: 16:10 aspect ratio
production_environment:
  os: Ubuntu
  type: VPS (headless)

# Project Scope and Workflow
project_scope:
  - Implement reliable recording and playback on local Windows machine
  - Address potential discrepancies due to 16:10 monitor setup
  - Enable translation of recorded routines to headless versions
  - Implement scheduling and concurrent execution of routines on Ubuntu VPS

development_workflow:
  - Develop and test recording/playback functionality on local machine
  - Implement calibration process if necessary for local setup
  - Create translation mechanism for headless execution
  - Develop scheduling and management system for VPS deployment

# Future Considerations
future_changes:
  - Transition from local development to VPS deployment
  - Adapt calibration process for headless environment
  - Implement multi-user support and concurrent routine execution
  - Optimize for scalability and performance in production environment
